
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "intermediate/optimizer_step_in_backward_tutorial.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_intermediate_optimizer_step_in_backward_tutorial.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_intermediate_optimizer_step_in_backward_tutorial.py:


How to save memory by fusing the optimizer step into the backward pass
======================================================================

Hello there! This tutorial aims to showcase one way of reducing the
memory footprint of a training loop by reducing the memory taken by
the *gradients*. Say you have a model and you're interested in ways to
optimize memory to avoid ``Out of Memory`` (OOM) errors or simply to ooze
more out of your GPU. Well, you _might_ be in luck (if gradients take up
a portion of your memory and you do not need to do gradient accumulation).
We will explore the following:

1. What takes up memory during your training or finetuning loop,
2. How to capture and visualize memory snapshots to determine the bottleneck,
3. The new ``Tensor.register_post_accumulate_grad_hook(hook)`` API, and finally,
4. How everything fits together in 10 lines to achieve memory savings.

To run this tutorial, you will need:

*  PyTorch 2.1.0 or newer with ``torchvision``
*  1 CUDA GPU if you'd like to run the memory visualizations locally.
   Otherwise, this technique would benefit similarly on any device.

Let us start by importing the required modules and models. We will use a
vision transformer model from torchvision, but feel free to substitute
with your own model. We will also use ``torch.optim.Adam`` as our optimizer,
but, again, feel free to substitute with your own optimizer.

.. GENERATED FROM PYTHON SOURCE LINES 31-39

.. code-block:: default


    import torch
    from torchvision import models
    from pickle import dump

    model = models.vit_l_16(weights='DEFAULT').cuda()
    optimizer = torch.optim.Adam(model.parameters())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading: "https://download.pytorch.org/models/vit_l_16-852ce7e3.pth" to /var/lib/jenkins/.cache/torch/hub/checkpoints/vit_l_16-852ce7e3.pth

      0%|          | 0.00/1.13G [00:00<?, ?B/s]
      1%|1         | 12.1M/1.13G [00:00<00:09, 127MB/s]
      2%|2         | 24.2M/1.13G [00:00<00:30, 38.6MB/s]
      3%|2         | 31.2M/1.13G [00:00<00:27, 43.3MB/s]
      3%|3         | 37.2M/1.13G [00:00<00:30, 38.6MB/s]
      4%|4         | 48.5M/1.13G [00:01<00:21, 53.4MB/s]
      5%|4         | 55.2M/1.13G [00:01<00:30, 38.0MB/s]
      6%|5         | 65.5M/1.13G [00:01<00:27, 41.1MB/s]
      7%|6         | 76.2M/1.13G [00:01<00:21, 52.9MB/s]
      7%|7         | 82.9M/1.13G [00:02<00:28, 39.1MB/s]
      8%|8         | 95.6M/1.13G [00:02<00:20, 54.2MB/s]
      9%|8         | 103M/1.13G [00:02<00:28, 39.1MB/s] 
     10%|9         | 113M/1.13G [00:02<00:30, 35.8MB/s]
     10%|#         | 118M/1.13G [00:02<00:30, 36.3MB/s]
     11%|#1        | 130M/1.13G [00:03<00:22, 47.1MB/s]
     12%|#1        | 136M/1.13G [00:03<00:38, 28.0MB/s]
     12%|#2        | 140M/1.13G [00:03<00:38, 27.6MB/s]
     13%|#2        | 146M/1.13G [00:04<00:40, 26.2MB/s]
     13%|#2        | 149M/1.13G [00:04<00:45, 23.1MB/s]
     13%|#3        | 156M/1.13G [00:04<00:34, 30.6MB/s]
     14%|#4        | 164M/1.13G [00:04<00:28, 36.3MB/s]
     15%|#5        | 176M/1.13G [00:04<00:19, 52.8MB/s]
     16%|#5        | 183M/1.13G [00:04<00:24, 41.5MB/s]
     17%|#6        | 196M/1.13G [00:05<00:18, 54.1MB/s]
     17%|#7        | 202M/1.13G [00:05<00:19, 51.4MB/s]
     18%|#8        | 213M/1.13G [00:05<00:17, 55.9MB/s]
     19%|#9        | 222M/1.13G [00:05<00:15, 63.2MB/s]
     20%|#9        | 229M/1.13G [00:05<00:18, 54.0MB/s]
     20%|##        | 234M/1.13G [00:06<00:25, 38.2MB/s]
     21%|##1       | 245M/1.13G [00:06<00:19, 50.4MB/s]
     22%|##1       | 251M/1.13G [00:06<00:24, 38.7MB/s]
     22%|##2       | 261M/1.13G [00:06<00:20, 46.5MB/s]
     23%|##2       | 267M/1.13G [00:06<00:22, 41.8MB/s]
     24%|##3       | 277M/1.13G [00:06<00:17, 54.3MB/s]
     24%|##4       | 284M/1.13G [00:07<00:19, 47.2MB/s]
     25%|##5       | 294M/1.13G [00:07<00:16, 55.5MB/s]
     26%|##5       | 300M/1.13G [00:07<00:17, 51.1MB/s]
     27%|##6       | 311M/1.13G [00:07<00:18, 48.2MB/s]
     28%|##7       | 323M/1.13G [00:07<00:14, 60.9MB/s]
     28%|##8       | 329M/1.13G [00:07<00:14, 58.2MB/s]
     29%|##9       | 339M/1.13G [00:08<00:16, 53.2MB/s]
     30%|##9       | 344M/1.13G [00:08<00:18, 46.5MB/s]
     31%|###       | 357M/1.13G [00:08<00:13, 62.9MB/s]
     31%|###1      | 364M/1.13G [00:08<00:19, 42.5MB/s]
     32%|###2      | 377M/1.13G [00:08<00:15, 52.2MB/s]
     33%|###3      | 388M/1.13G [00:08<00:12, 64.0MB/s]
     34%|###4      | 396M/1.13G [00:09<00:13, 61.0MB/s]
     35%|###5      | 408M/1.13G [00:09<00:10, 72.0MB/s]
     36%|###5      | 416M/1.13G [00:09<00:11, 68.5MB/s]
     37%|###6      | 426M/1.13G [00:09<00:11, 65.5MB/s]
     37%|###7      | 433M/1.13G [00:09<00:11, 65.8MB/s]
     38%|###8      | 442M/1.13G [00:09<00:13, 54.9MB/s]
     39%|###9      | 454M/1.13G [00:10<00:10, 68.9MB/s]
     40%|###9      | 462M/1.13G [00:10<00:17, 42.1MB/s]
     41%|####      | 474M/1.13G [00:10<00:14, 50.5MB/s]
     41%|####1     | 480M/1.13G [00:10<00:16, 42.7MB/s]
     42%|####2     | 490M/1.13G [00:10<00:13, 52.6MB/s]
     43%|####2     | 497M/1.13G [00:11<00:13, 50.5MB/s]
     44%|####3     | 506M/1.13G [00:11<00:14, 45.9MB/s]
     44%|####4     | 512M/1.13G [00:11<00:17, 37.9MB/s]
     45%|####5     | 524M/1.13G [00:11<00:13, 49.9MB/s]
     46%|####5     | 534M/1.13G [00:11<00:11, 59.3MB/s]
     47%|####6     | 541M/1.13G [00:12<00:15, 42.8MB/s]
     48%|####7     | 553M/1.13G [00:12<00:11, 56.8MB/s]
     48%|####8     | 560M/1.13G [00:12<00:13, 46.7MB/s]
     49%|####9     | 572M/1.13G [00:12<00:10, 57.3MB/s]
     50%|####9     | 579M/1.13G [00:12<00:11, 52.6MB/s]
     51%|#####     | 590M/1.13G [00:13<00:11, 50.3MB/s]
     51%|#####1    | 598M/1.13G [00:13<00:11, 51.9MB/s]
     52%|#####2    | 605M/1.13G [00:13<00:13, 41.7MB/s]
     52%|#####2    | 609M/1.13G [00:13<00:16, 36.0MB/s]
     54%|#####3    | 621M/1.13G [00:13<00:11, 51.0MB/s]
     54%|#####4    | 628M/1.13G [00:13<00:11, 50.4MB/s]
     55%|#####4    | 637M/1.13G [00:14<00:09, 60.8MB/s]
     55%|#####5    | 644M/1.13G [00:14<00:11, 49.0MB/s]
     57%|#####6    | 656M/1.13G [00:14<00:08, 64.0MB/s]
     58%|#####7    | 670M/1.13G [00:14<00:07, 70.9MB/s]
     58%|#####8    | 678M/1.13G [00:14<00:10, 50.5MB/s]
     59%|#####9    | 688M/1.13G [00:15<00:09, 54.7MB/s]
     60%|#####9    | 694M/1.13G [00:15<00:09, 54.2MB/s]
     60%|######    | 700M/1.13G [00:15<00:09, 49.4MB/s]
     61%|######    | 705M/1.13G [00:15<00:14, 32.4MB/s]
     62%|######1   | 718M/1.13G [00:15<00:09, 47.9MB/s]
     62%|######2   | 724M/1.13G [00:16<00:13, 33.8MB/s]
     63%|######3   | 737M/1.13G [00:16<00:09, 46.2MB/s]
     64%|######4   | 743M/1.13G [00:16<00:11, 39.4MB/s]
     64%|######4   | 749M/1.13G [00:16<00:10, 40.8MB/s]
     65%|######4   | 754M/1.13G [00:16<00:12, 33.9MB/s]
     65%|######5   | 759M/1.13G [00:17<00:12, 32.6MB/s]
     66%|######6   | 769M/1.13G [00:17<00:12, 32.9MB/s]
     67%|######6   | 773M/1.13G [00:17<00:13, 30.0MB/s]
     68%|######7   | 786M/1.13G [00:17<00:09, 41.2MB/s]
     69%|######8   | 798M/1.13G [00:17<00:07, 53.9MB/s]
     69%|######9   | 804M/1.13G [00:18<00:07, 48.6MB/s]
     70%|######9   | 812M/1.13G [00:18<00:06, 54.7MB/s]
     70%|#######   | 818M/1.13G [00:18<00:06, 56.6MB/s]
     71%|#######   | 824M/1.13G [00:18<00:08, 43.7MB/s]
     71%|#######1  | 829M/1.13G [00:18<00:09, 38.4MB/s]
     72%|#######1  | 836M/1.13G [00:18<00:09, 36.0MB/s]
     73%|#######2  | 845M/1.13G [00:19<00:07, 47.2MB/s]
     73%|#######3  | 852M/1.13G [00:19<00:06, 49.6MB/s]
     74%|#######3  | 857M/1.13G [00:19<00:09, 32.1MB/s]
     75%|#######4  | 868M/1.13G [00:19<00:06, 45.0MB/s]
     75%|#######5  | 874M/1.13G [00:19<00:07, 39.8MB/s]
     76%|#######6  | 884M/1.13G [00:20<00:07, 40.8MB/s]
     77%|#######6  | 889M/1.13G [00:20<00:07, 38.7MB/s]
     77%|#######7  | 900M/1.13G [00:20<00:05, 46.0MB/s]
     78%|#######7  | 904M/1.13G [00:20<00:06, 40.8MB/s]
     79%|#######8  | 916M/1.13G [00:20<00:05, 42.9MB/s]
     79%|#######9  | 920M/1.13G [00:21<00:06, 36.5MB/s]
     80%|########  | 930M/1.13G [00:21<00:05, 47.1MB/s]
     81%|########  | 935M/1.13G [00:21<00:05, 43.8MB/s]
     82%|########1 | 950M/1.13G [00:21<00:03, 62.9MB/s]
     83%|########2 | 961M/1.13G [00:21<00:02, 74.2MB/s]
     83%|########3 | 969M/1.13G [00:21<00:04, 46.1MB/s]
     85%|########4 | 983M/1.13G [00:22<00:03, 54.3MB/s]
     85%|########5 | 990M/1.13G [00:22<00:03, 53.3MB/s]
     86%|########6 | 999M/1.13G [00:22<00:03, 51.1MB/s]
     87%|########7 | 0.99G/1.13G [00:22<00:02, 63.6MB/s]
     88%|########7 | 1.00G/1.13G [00:22<00:02, 54.1MB/s]
     88%|########8 | 1.00G/1.13G [00:23<00:02, 51.7MB/s]
     89%|########8 | 1.01G/1.13G [00:23<00:02, 46.9MB/s]
     90%|########9 | 1.02G/1.13G [00:23<00:01, 62.5MB/s]
     91%|######### | 1.03G/1.13G [00:23<00:01, 59.9MB/s]
     92%|#########1| 1.04G/1.13G [00:23<00:01, 79.0MB/s]
     92%|#########2| 1.05G/1.13G [00:23<00:01, 70.6MB/s]
     93%|#########3| 1.06G/1.13G [00:23<00:01, 68.7MB/s]
     94%|#########3| 1.06G/1.13G [00:23<00:01, 58.8MB/s]
     94%|#########4| 1.07G/1.13G [00:24<00:01, 59.6MB/s]
     95%|#########4| 1.08G/1.13G [00:24<00:01, 42.5MB/s]
     95%|#########5| 1.08G/1.13G [00:24<00:01, 42.0MB/s]
     96%|#########5| 1.09G/1.13G [00:24<00:01, 39.4MB/s]
     97%|#########6| 1.10G/1.13G [00:24<00:00, 54.0MB/s]
     97%|#########7| 1.10G/1.13G [00:25<00:00, 41.8MB/s]
     99%|#########8| 1.12G/1.13G [00:25<00:00, 59.4MB/s]
     99%|#########9| 1.13G/1.13G [00:25<00:00, 40.5MB/s]
    100%|##########| 1.13G/1.13G [00:25<00:00, 47.5MB/s]




.. GENERATED FROM PYTHON SOURCE LINES 40-43

Now let's define our typical training loop. You should use real images when
training, but for the purposes of this tutorial, we are passing in fake
inputs and not worrying about loading any actual data.

.. GENERATED FROM PYTHON SOURCE LINES 43-58

.. code-block:: default


    IMAGE_SIZE = 224

    def train(model, optimizer):
      # create our fake image input: tensor shape is batch_size, channels, height, width
      fake_image = torch.rand(1, 3, IMAGE_SIZE, IMAGE_SIZE).cuda()

      # call our forward and backward
      loss = model.forward(fake_image)
      loss.sum().backward()

      # optimizer update
      optimizer.step()
      optimizer.zero_grad()








.. GENERATED FROM PYTHON SOURCE LINES 59-76

Memory usage during training
""""""""""""""""""""""""""""
We are about to look at some memory snapshots, so we should be prepared to
analyze them properly. Typically, training memory consists of:

 * Model parameters (size P)
 * Activations that are saved for the backward pass (size A)
 * Gradients, which are the same size as the model parameters, so size G = P.
 * Optimizer state, which is proportional to the size of the parameters. In
   this case, the state for Adam requires 2x the model parameters, so size O = 2P.
 * Intermediate tensors, which are allocated throughout the compute. We will
   not worry about them for now as they are usually small and ephemeral.

Capturing and visualizing memory snapshots
""""""""""""""""""""""""""""""""""""""""""
Let's get us a memory snapshot! As your code runs, consider what you may expect
the CUDA memory timeline to look like.

.. GENERATED FROM PYTHON SOURCE LINES 76-92

.. code-block:: default


    # tell CUDA to start recording memory allocations
    torch.cuda.memory._record_memory_history(enabled='all')

    # train 3 steps
    for _ in range(3):
      train(model, optimizer)

    # save a snapshot of the memory allocations
    s = torch.cuda.memory._snapshot()
    with open(f"snapshot.pickle", "wb") as f:
        dump(s, f)

    # tell CUDA to stop recording memory allocations now
    torch.cuda.memory._record_memory_history(enabled=None)








.. GENERATED FROM PYTHON SOURCE LINES 93-170

Now open up the snapshot in the CUDA Memory Visualizer at
https://pytorch.org/memory_viz by dragging and dropping the
``snapshot.pickle`` file. Does the memory timeline match your expectations?

.. figure:: /_static/img/optim_step_in_bwd/snapshot.jpg
   :alt: snapshot.png loaded into CUDA Memory Visualizer

The model parameters have already been loaded in memory before the training
step, so we see a chunk of memory devoted to the weights right off the bat.
As we start our forward pass, memory is allocated gradually for the activations,
or the tensors we are saving to be able to compute gradients in the backward pass.
Once we start the backward pass, the activations are gradually freed while memory
of the gradients starts building up.

Lastly, as the optimizer kicks in, its state will be lazily initialized, so we 
should see the optimizer state memory gradually increase during the optimizer
step of the first training loop only. In future loops, the optimizer memory
will remain and be updated in-place. The memory for the gradients is then
freed accordingly at the end of every training loop when ``zero_grad`` is called.

Where is the memory bottleneck in this training loop? Or, in other words,
where is the peak memory?

The peak memory usage is during the optimizer step! Note the memory then
consists of ~1.2GB of parameters, ~1.2GB of gradients, and ~2.4GB=2*1.2GB of
the optimizer state as expected. The last ~1.2GB comes from Adam optimizer
requiring memory for intermediates, totaling to ~6GB of peak memory.
Technically, you can remove the need for the last 1.2GB for optimizer
intermediates if you set ``Adam(model.parameters(), foreach=False)`` which
would trade off runtime for memory. If switching off the ``foreach`` runtime
optimization is sufficient in memory savings for you, nice, but please
read on if you're curious how this tutorial can help you do better!
With the technique we will soon introduce, we will reduce peak memory by
removing the need for the ~1.2GB of **gradients memory** as well as **optimizer
intermediates memory**. Now, what would you expect the new peak memory to be?
The answer will be revealed in the `next` snapshot.

DISCLAIMER: This technique is **not** for all
"""""""""""""""""""""""""""""""""""""""""""""
Before we get too excited, we have to consider whether this technique is applicable
for `your` use case. This is NOT a silver bullet! The technique of fusing the 
optimizer step into the backward only targets reducing *gradient* memory (and as a side effect also optimizer intermediates
memory). Thus, the more sizable the memory taken up by the gradients, the more
tantamount the memory reduction. In our example above, the gradients eat up 20% 
of the memory pie, which is quite sizable!

This may not be the case for you, for example, if your weights are already tiny,
(say, due to applying LoRa,) then the gradients do not take much space in your
training loop and the wins are way less exciting. In that case, you should
first try other techniques like activations checkpointing, distributed
training, quantization, or reducing the batch size. Then, when the gradients
are part of the bottleneck again, come back to this tutorial!

Still here? Cool, let's introduce our new ``register_post_accumulate_grad_hook(hook)``
API on Tensor.

``Tensor.register_post_accumulate_grad_hook(hook)`` API and our technique
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Our technique relies on not having to save the gradients during ``backward()``. Instead,
once a gradient has been accumulated, we will immediately apply the optimizer to
the corresponding parameter and drop that gradient entirely! This removes the need
for holding onto a big buffer of gradients until the optimizer step.

So how can we unlock the behavior of applying the optimizer more eagerly? In our 2.1
release, we've added a new API :func:`torch.Tensor.register_post_accumulate_grad_hook`
that would allow us to add a hook onto a Tensor once its ``.grad`` field has been
accumulated. We will encapsulate the optimizer step into this hook. How?

How everything fits together in 10 lines
""""""""""""""""""""""""""""""""""""""""
Remember our model and optimizer setup from the beginning? I'll leave them commented
out below so we don't spend resources rerunning the code.

.. code-block:: python

   model = models.vit_l_16(weights='DEFAULT').cuda()
   optimizer = torch.optim.Adam(model.parameters())

.. GENERATED FROM PYTHON SOURCE LINES 170-198

.. code-block:: default


    # Instead of having just *one* optimizer, we will have a ``dict`` of optimizers
    # for every parameter so we could reference them in our hook.
    optimizer_dict = {p: torch.optim.Adam([p], foreach=False) for p in model.parameters()}

    # Define our hook, which will call the optimizer ``step()`` and ``zero_grad()``
    def optimizer_hook(parameter) -> None:
      optimizer_dict[parameter].step()
      optimizer_dict[parameter].zero_grad()

    # Register the hook onto every parameter
    for p in model.parameters():
       p.register_post_accumulate_grad_hook(optimizer_hook)

    # Now remember our previous ``train()`` function? Since the optimizer has been
    # fused into the backward, we can remove the optimizer step and zero_grad calls.
    def train(model):
      # create our fake image input: tensor shape is batch_size, channels, height, width
      fake_image = torch.rand(1, 3, IMAGE_SIZE, IMAGE_SIZE).cuda()

      # call our forward and backward
      loss = model.forward(fake_image)
      loss.sum().backward()

      # optimizer update --> no longer needed!
      # optimizer.step()
      # optimizer.zero_grad()








.. GENERATED FROM PYTHON SOURCE LINES 199-211

That took about 10 lines of changes in our sample model, which is neat.
However, for real models, it could be a fairly intrusive change to switch
out the optimizer for an optimizer dictionary, especially for those who use
``LRScheduler``s or manipulate optimizer configuration throughout the
training epochs. Working out this API with those changes will be more
involved and will likely require moving more configuration into global
state but should not be impossible. That said, a next step for PyTorch
is to make this API easier to adopt with LRSchedulers and other features
you are already used to.

But let me get back to convincing you that this technique is worth it.
We will consult our friend, the memory snapshot.

.. GENERATED FROM PYTHON SOURCE LINES 211-231

.. code-block:: default


    # delete optimizer memory from before to get a clean slate for the next
    # memory snapshot
    del optimizer

    # tell CUDA to start recording memory allocations
    torch.cuda.memory._record_memory_history(enabled='all')

    # train 3 steps. note that we no longer pass the optimizer into train()
    for _ in range(3):
      train(model)

    # save a snapshot of the memory allocations
    s = torch.cuda.memory._snapshot()
    with open(f"snapshot-opt-in-bwd.pickle", "wb") as f:
        dump(s, f)

    # tell CUDA to stop recording memory allocations now
    torch.cuda.memory._record_memory_history(enabled=None)








.. GENERATED FROM PYTHON SOURCE LINES 232-268

Yes, take some time to drag your snapshot into the CUDA Memory Visualizer.

.. figure:: /_static/img/optim_step_in_bwd/snapshot_opt_in_bwd.jpg
   :alt: snapshot.png loaded into CUDA Memory Visualizer

Several major observations:
 1. There is no more optimizer step! Right...we fused that into the backward.
 2. Likewise, the backward drags longer and there are more random allocations
    for intermediates. This is expected, as the optimizer step requires 
    intermediates.
 3. Most importantly! The peak memory is lower! It is now ~4GB (which I
    hope maps closely to your earlier expectation). 

Note that there is no longer any big chunk of memory allocated for the gradients
compared to before, accounting for ~1.2GB of memory savings. Instead, we've freed
each gradient very quickly after they've been computed by moving the optimizer 
step as far ahead as we can. Woohoo! By the way, the other ~1.2GB of memory savings
comes from breaking apart the optimizer into per-parameter optimizers, so the
intermediates have proportionally shrunk. This detail is `less important` than
the gradient memory savings, as you can get optimizer intermediates savings
from just turning ``foreach=False`` without this technique.

You may be correctly wondering: if we saved 2.4GB of memory, why is the peak memory
NOT 6GB - 2.4GB = 3.6GB? Well, the peak has moved! The peak is now near the start
of the backward step, when we still have activations in memory, where before, the peak
was during the optimizer step when the activations had been freed. The ~0.4GB difference
accounting for ~4.0GB - ~3.6GB is thus due to the activations memory. One can then
imagine that this technique can be coupled with activations checkpointing for more
memory wins.

Conclusion
""""""""""
In this tutorial, we learned about the memory saving technique of
fusing the optimizer into the backward step through the new
``Tensor.register_post_accumulate_grad_hook()`` API and *when* to apply this
technique (when gradients memory is significant). Along the way, we also learned
about memory snapshots, which are generally useful in memory optimization.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  35.049 seconds)


.. _sphx_glr_download_intermediate_optimizer_step_in_backward_tutorial.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: optimizer_step_in_backward_tutorial.py <optimizer_step_in_backward_tutorial.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: optimizer_step_in_backward_tutorial.ipynb <optimizer_step_in_backward_tutorial.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
