
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "intermediate/spatial_transformer_tutorial.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_intermediate_spatial_transformer_tutorial.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_intermediate_spatial_transformer_tutorial.py:


Spatial Transformer Networks Tutorial
=====================================
**Author**: `Ghassen HAMROUNI <https://github.com/GHamrouni>`_

.. figure:: /_static/img/stn/FSeq.png

In this tutorial, you will learn how to augment your network using
a visual attention mechanism called spatial transformer
networks. You can read more about the spatial transformer
networks in the `DeepMind paper <https://arxiv.org/abs/1506.02025>`__

Spatial transformer networks are a generalization of differentiable
attention to any spatial transformation. Spatial transformer networks
(STN for short) allow a neural network to learn how to perform spatial
transformations on the input image in order to enhance the geometric
invariance of the model.
For example, it can crop a region of interest, scale and correct
the orientation of an image. It can be a useful mechanism because CNNs
are not invariant to rotation and scale and more general affine
transformations.

One of the best things about STN is the ability to simply plug it into
any existing CNN with very little modification.

.. GENERATED FROM PYTHON SOURCE LINES 27-41

.. code-block:: default

    # License: BSD
    # Author: Ghassen Hamrouni

    import torch
    import torch.nn as nn
    import torch.nn.functional as F
    import torch.optim as optim
    import torchvision
    from torchvision import datasets, transforms
    import matplotlib.pyplot as plt
    import numpy as np

    plt.ion()   # interactive mode





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <contextlib.ExitStack object at 0x7fbe5259ab30>



.. GENERATED FROM PYTHON SOURCE LINES 42-48

Loading the data
----------------

In this post we experiment with the classic MNIST dataset. Using a
standard convolutional network augmented with a spatial transformer
network.

.. GENERATED FROM PYTHON SOURCE LINES 48-70

.. code-block:: default


    from six.moves import urllib
    opener = urllib.request.build_opener()
    opener.addheaders = [('User-agent', 'Mozilla/5.0')]
    urllib.request.install_opener(opener)

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    # Training dataset
    train_loader = torch.utils.data.DataLoader(
        datasets.MNIST(root='.', train=True, download=True,
                       transform=transforms.Compose([
                           transforms.ToTensor(),
                           transforms.Normalize((0.1307,), (0.3081,))
                       ])), batch_size=64, shuffle=True, num_workers=4)
    # Test dataset
    test_loader = torch.utils.data.DataLoader(
        datasets.MNIST(root='.', train=False, transform=transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize((0.1307,), (0.3081,))
        ])), batch_size=64, shuffle=True, num_workers=4)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz
    Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz to ./MNIST/raw/train-images-idx3-ubyte.gz

      0%|          | 0/9912422 [00:00<?, ?it/s]
    100%|##########| 9912422/9912422 [00:00<00:00, 499942415.85it/s]
    Extracting ./MNIST/raw/train-images-idx3-ubyte.gz to ./MNIST/raw

    Downloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz
    Downloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz to ./MNIST/raw/train-labels-idx1-ubyte.gz

      0%|          | 0/28881 [00:00<?, ?it/s]
    100%|##########| 28881/28881 [00:00<00:00, 43762895.17it/s]
    Extracting ./MNIST/raw/train-labels-idx1-ubyte.gz to ./MNIST/raw

    Downloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz
    Downloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz to ./MNIST/raw/t10k-images-idx3-ubyte.gz

      0%|          | 0/1648877 [00:00<?, ?it/s]
    100%|##########| 1648877/1648877 [00:00<00:00, 279904945.63it/s]
    Extracting ./MNIST/raw/t10k-images-idx3-ubyte.gz to ./MNIST/raw

    Downloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz
    Downloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz to ./MNIST/raw/t10k-labels-idx1-ubyte.gz

      0%|          | 0/4542 [00:00<?, ?it/s]
    100%|##########| 4542/4542 [00:00<00:00, 65241536.88it/s]
    Extracting ./MNIST/raw/t10k-labels-idx1-ubyte.gz to ./MNIST/raw





.. GENERATED FROM PYTHON SOURCE LINES 71-91

Depicting spatial transformer networks
--------------------------------------

Spatial transformer networks boils down to three main components :

-  The localization network is a regular CNN which regresses the
   transformation parameters. The transformation is never learned
   explicitly from this dataset, instead the network learns automatically
   the spatial transformations that enhances the global accuracy.
-  The grid generator generates a grid of coordinates in the input
   image corresponding to each pixel from the output image.
-  The sampler uses the parameters of the transformation and applies
   it to the input image.

.. figure:: /_static/img/stn/stn-arch.png

.. Note::
   We need the latest version of PyTorch that contains
   affine_grid and grid_sample modules.


.. GENERATED FROM PYTHON SOURCE LINES 91-151

.. code-block:: default



    class Net(nn.Module):
        def __init__(self):
            super(Net, self).__init__()
            self.conv1 = nn.Conv2d(1, 10, kernel_size=5)
            self.conv2 = nn.Conv2d(10, 20, kernel_size=5)
            self.conv2_drop = nn.Dropout2d()
            self.fc1 = nn.Linear(320, 50)
            self.fc2 = nn.Linear(50, 10)

            # Spatial transformer localization-network
            self.localization = nn.Sequential(
                nn.Conv2d(1, 8, kernel_size=7),
                nn.MaxPool2d(2, stride=2),
                nn.ReLU(True),
                nn.Conv2d(8, 10, kernel_size=5),
                nn.MaxPool2d(2, stride=2),
                nn.ReLU(True)
            )

            # Regressor for the 3 * 2 affine matrix
            self.fc_loc = nn.Sequential(
                nn.Linear(10 * 3 * 3, 32),
                nn.ReLU(True),
                nn.Linear(32, 3 * 2)
            )

            # Initialize the weights/bias with identity transformation
            self.fc_loc[2].weight.data.zero_()
            self.fc_loc[2].bias.data.copy_(torch.tensor([1, 0, 0, 0, 1, 0], dtype=torch.float))

        # Spatial transformer network forward function
        def stn(self, x):
            xs = self.localization(x)
            xs = xs.view(-1, 10 * 3 * 3)
            theta = self.fc_loc(xs)
            theta = theta.view(-1, 2, 3)

            grid = F.affine_grid(theta, x.size())
            x = F.grid_sample(x, grid)

            return x

        def forward(self, x):
            # transform the input
            x = self.stn(x)

            # Perform the usual forward pass
            x = F.relu(F.max_pool2d(self.conv1(x), 2))
            x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))
            x = x.view(-1, 320)
            x = F.relu(self.fc1(x))
            x = F.dropout(x, training=self.training)
            x = self.fc2(x)
            return F.log_softmax(x, dim=1)


    model = Net().to(device)








.. GENERATED FROM PYTHON SOURCE LINES 152-158

Training the model
------------------

Now, let's use the SGD algorithm to train the model. The network is
learning the classification task in a supervised way. In the same time
the model is learning STN automatically in an end-to-end fashion.

.. GENERATED FROM PYTHON SOURCE LINES 158-202

.. code-block:: default



    optimizer = optim.SGD(model.parameters(), lr=0.01)


    def train(epoch):
        model.train()
        for batch_idx, (data, target) in enumerate(train_loader):
            data, target = data.to(device), target.to(device)

            optimizer.zero_grad()
            output = model(data)
            loss = F.nll_loss(output, target)
            loss.backward()
            optimizer.step()
            if batch_idx % 500 == 0:
                print('Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'.format(
                    epoch, batch_idx * len(data), len(train_loader.dataset),
                    100. * batch_idx / len(train_loader), loss.item()))
    #
    # A simple test procedure to measure the STN performances on MNIST.
    #


    def test():
        with torch.no_grad():
            model.eval()
            test_loss = 0
            correct = 0
            for data, target in test_loader:
                data, target = data.to(device), target.to(device)
                output = model(data)

                # sum up batch loss
                test_loss += F.nll_loss(output, target, size_average=False).item()
                # get the index of the max log-probability
                pred = output.max(1, keepdim=True)[1]
                correct += pred.eq(target.view_as(pred)).sum().item()

            test_loss /= len(test_loader.dataset)
            print('\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'
                  .format(test_loss, correct, len(test_loader.dataset),
                          100. * correct / len(test_loader.dataset)))








.. GENERATED FROM PYTHON SOURCE LINES 203-211

Visualizing the STN results
---------------------------

Now, we will inspect the results of our learned visual attention
mechanism.

We define a small helper function in order to visualize the
transformations while training.

.. GENERATED FROM PYTHON SOURCE LINES 211-258

.. code-block:: default



    def convert_image_np(inp):
        """Convert a Tensor to numpy image."""
        inp = inp.numpy().transpose((1, 2, 0))
        mean = np.array([0.485, 0.456, 0.406])
        std = np.array([0.229, 0.224, 0.225])
        inp = std * inp + mean
        inp = np.clip(inp, 0, 1)
        return inp

    # We want to visualize the output of the spatial transformers layer
    # after the training, we visualize a batch of input images and
    # the corresponding transformed batch using STN.


    def visualize_stn():
        with torch.no_grad():
            # Get a batch of training data
            data = next(iter(test_loader))[0].to(device)

            input_tensor = data.cpu()
            transformed_input_tensor = model.stn(data).cpu()

            in_grid = convert_image_np(
                torchvision.utils.make_grid(input_tensor))

            out_grid = convert_image_np(
                torchvision.utils.make_grid(transformed_input_tensor))

            # Plot the results side-by-side
            f, axarr = plt.subplots(1, 2)
            axarr[0].imshow(in_grid)
            axarr[0].set_title('Dataset Images')

            axarr[1].imshow(out_grid)
            axarr[1].set_title('Transformed Images')

    for epoch in range(1, 20 + 1):
        train(epoch)
        test()

    # Visualize the STN transformation on some input batch
    visualize_stn()

    plt.ioff()
    plt.show()



.. image-sg:: /intermediate/images/sphx_glr_spatial_transformer_tutorial_001.png
   :alt: Dataset Images, Transformed Images
   :srcset: /intermediate/images/sphx_glr_spatial_transformer_tutorial_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /opt/conda/lib/python3.10/site-packages/torch/nn/functional.py:4298: UserWarning:

    Default grid_sample and affine_grid behavior has changed to align_corners=False since 1.3.0. Please specify align_corners=True if the old behavior is desired. See the documentation of grid_sample for details.

    /opt/conda/lib/python3.10/site-packages/torch/nn/functional.py:4236: UserWarning:

    Default grid_sample and affine_grid behavior has changed to align_corners=False since 1.3.0. Please specify align_corners=True if the old behavior is desired. See the documentation of grid_sample for details.

    Train Epoch: 1 [0/60000 (0%)]   Loss: 2.315648
    Train Epoch: 1 [32000/60000 (53%)]      Loss: 1.096619
    /opt/conda/lib/python3.10/site-packages/torch/nn/_reduction.py:42: UserWarning:

    size_average and reduce args will be deprecated, please use reduction='sum' instead.


    Test set: Average loss: 0.2948, Accuracy: 9148/10000 (91%)

    Train Epoch: 2 [0/60000 (0%)]   Loss: 0.588206
    Train Epoch: 2 [32000/60000 (53%)]      Loss: 0.318479

    Test set: Average loss: 0.1349, Accuracy: 9596/10000 (96%)

    Train Epoch: 3 [0/60000 (0%)]   Loss: 0.330055
    Train Epoch: 3 [32000/60000 (53%)]      Loss: 0.226135

    Test set: Average loss: 0.1257, Accuracy: 9608/10000 (96%)

    Train Epoch: 4 [0/60000 (0%)]   Loss: 0.463460
    Train Epoch: 4 [32000/60000 (53%)]      Loss: 0.126672

    Test set: Average loss: 0.1351, Accuracy: 9598/10000 (96%)

    Train Epoch: 5 [0/60000 (0%)]   Loss: 0.270349
    Train Epoch: 5 [32000/60000 (53%)]      Loss: 0.172899

    Test set: Average loss: 0.1329, Accuracy: 9583/10000 (96%)

    Train Epoch: 6 [0/60000 (0%)]   Loss: 0.206486
    Train Epoch: 6 [32000/60000 (53%)]      Loss: 0.109318

    Test set: Average loss: 0.0745, Accuracy: 9783/10000 (98%)

    Train Epoch: 7 [0/60000 (0%)]   Loss: 0.080339
    Train Epoch: 7 [32000/60000 (53%)]      Loss: 0.254253

    Test set: Average loss: 0.0706, Accuracy: 9778/10000 (98%)

    Train Epoch: 8 [0/60000 (0%)]   Loss: 0.160534
    Train Epoch: 8 [32000/60000 (53%)]      Loss: 0.074818

    Test set: Average loss: 0.0658, Accuracy: 9806/10000 (98%)

    Train Epoch: 9 [0/60000 (0%)]   Loss: 0.121857
    Train Epoch: 9 [32000/60000 (53%)]      Loss: 0.138415

    Test set: Average loss: 0.0677, Accuracy: 9789/10000 (98%)

    Train Epoch: 10 [0/60000 (0%)]  Loss: 0.054339
    Train Epoch: 10 [32000/60000 (53%)]     Loss: 0.198625

    Test set: Average loss: 0.0621, Accuracy: 9799/10000 (98%)

    Train Epoch: 11 [0/60000 (0%)]  Loss: 0.121543
    Train Epoch: 11 [32000/60000 (53%)]     Loss: 0.112262

    Test set: Average loss: 0.0671, Accuracy: 9805/10000 (98%)

    Train Epoch: 12 [0/60000 (0%)]  Loss: 0.142003
    Train Epoch: 12 [32000/60000 (53%)]     Loss: 0.160235

    Test set: Average loss: 0.0502, Accuracy: 9847/10000 (98%)

    Train Epoch: 13 [0/60000 (0%)]  Loss: 0.115968
    Train Epoch: 13 [32000/60000 (53%)]     Loss: 0.047287

    Test set: Average loss: 0.0500, Accuracy: 9837/10000 (98%)

    Train Epoch: 14 [0/60000 (0%)]  Loss: 0.085934
    Train Epoch: 14 [32000/60000 (53%)]     Loss: 0.075549

    Test set: Average loss: 0.0498, Accuracy: 9857/10000 (99%)

    Train Epoch: 15 [0/60000 (0%)]  Loss: 0.069708
    Train Epoch: 15 [32000/60000 (53%)]     Loss: 0.058586

    Test set: Average loss: 0.0454, Accuracy: 9866/10000 (99%)

    Train Epoch: 16 [0/60000 (0%)]  Loss: 0.058987
    Train Epoch: 16 [32000/60000 (53%)]     Loss: 0.157207

    Test set: Average loss: 0.0479, Accuracy: 9870/10000 (99%)

    Train Epoch: 17 [0/60000 (0%)]  Loss: 0.312473
    Train Epoch: 17 [32000/60000 (53%)]     Loss: 0.364773

    Test set: Average loss: 0.0501, Accuracy: 9849/10000 (98%)

    Train Epoch: 18 [0/60000 (0%)]  Loss: 0.044765
    Train Epoch: 18 [32000/60000 (53%)]     Loss: 0.081272

    Test set: Average loss: 0.0434, Accuracy: 9865/10000 (99%)

    Train Epoch: 19 [0/60000 (0%)]  Loss: 0.076520
    Train Epoch: 19 [32000/60000 (53%)]     Loss: 0.091184

    Test set: Average loss: 0.0501, Accuracy: 9848/10000 (98%)

    Train Epoch: 20 [0/60000 (0%)]  Loss: 0.059130
    Train Epoch: 20 [32000/60000 (53%)]     Loss: 0.077091

    Test set: Average loss: 0.0747, Accuracy: 9768/10000 (98%)

    Exception ignored in: <function _MultiProcessingDataLoaderIter.__del__ at 0x7fbe8069bb50>
    Traceback (most recent call last):
      File "/opt/conda/lib/python3.10/site-packages/torch/utils/data/dataloader.py", line 1478, in __del__
        self._shutdown_workers()
      File "/opt/conda/lib/python3.10/site-packages/torch/utils/data/dataloader.py", line 1442, in _shutdown_workers
        w.join(timeout=_utils.MP_STATUS_CHECK_INTERVAL)
      File "/opt/conda/lib/python3.10/multiprocessing/process.py", line 149, in join
        res = self._popen.wait(timeout)
      File "/opt/conda/lib/python3.10/multiprocessing/popen_fork.py", line 40, in wait
        if not wait([self.sentinel], timeout):
      File "/opt/conda/lib/python3.10/multiprocessing/connection.py", line 931, in wait
        ready = selector.select(timeout)
      File "/opt/conda/lib/python3.10/selectors.py", line 416, in select
        fd_event_list = self._selector.poll(timeout)
      File "/opt/conda/lib/python3.10/site-packages/torch/utils/data/_utils/signal_handling.py", line 66, in handler
        _error_if_any_worker_fails()
    RuntimeError: DataLoader worker (pid 7052) is killed by signal: Aborted. 





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  37.647 seconds)


.. _sphx_glr_download_intermediate_spatial_transformer_tutorial.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: spatial_transformer_tutorial.py <spatial_transformer_tutorial.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: spatial_transformer_tutorial.ipynb <spatial_transformer_tutorial.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
